/**
 * Cloudflare Email-to-SMS Worker
 * Receives emails via Email Routing and sends SMS via Twilio
 */

import PostalMime from 'postal-mime';
import type { Env, ForwardableEmailMessage, ParsedEmail, LogEntry } from '../types';
import { createLogger, type Logger } from '../utils/logger';
import { createValidator, ValidationError } from '../middleware/validator';
import { createRateLimiter } from '../middleware/rate-limiter';
import { extractPhoneNumber } from '../utils/phone-parser';
import { processEmailContent } from '../utils/content-processor';
import { createTwilioService, TwilioError } from '../services/twilio-service';

/**
 * Email Worker Handler
 * This is the main entry point for Cloudflare Email Routing
 */
export default {
  async email(message: ForwardableEmailMessage, env: Env, ctx: ExecutionContext): Promise<void> {
    const startTime = Date.now();
    const logger = createLogger(env);

    logger.info('Email received', {
      from: message.from,
      to: message.to,
      size: message.rawSize,
    });

    try {
      // 1. Parse email content
      const email = await parseEmail(message);
      logger.debug('Email parsed successfully', {
        subject: email.subject,
        textLength: email.text.length,
        hasHtml: !!email.html,
      });

      // 2. Validate email
      const validator = createValidator(env, logger);
      validator.validateSender(email.from);
      validator.validateEmail(email);

      // 3. Extract phone number
      const phoneResult = extractPhoneNumber(email);
      logger.info('Phone number extracted', {
        phone: phoneResult.phoneNumber,
        source: phoneResult.source,
        confidence: phoneResult.confidence,
      });

      validator.validatePhoneNumber(phoneResult.phoneNumber);

      // 4. Check rate limits
      if (env.EMAIL_SMS_KV) {
        const rateLimiter = createRateLimiter(env, logger);

        const senderLimit = await rateLimiter.checkSenderLimit(email.from);
        if (!senderLimit.allowed) {
          message.setReject(senderLimit.reason || 'Rate limit exceeded for sender');
          logger.warn('Sender rate limit exceeded', { from: email.from });
          return;
        }

        const recipientLimit = await rateLimiter.checkRecipientLimit(phoneResult.phoneNumber);
        if (!recipientLimit.allowed) {
          message.setReject(recipientLimit.reason || 'Rate limit exceeded for recipient');
          logger.warn('Recipient rate limit exceeded', { to: phoneResult.phoneNumber });
          return;
        }

        const globalLimit = await rateLimiter.checkGlobalLimit();
        if (!globalLimit.allowed) {
          message.setReject('System rate limit exceeded. Please try again later.');
          logger.warn('Global rate limit exceeded');
          return;
        }

        logger.info('Rate limit checks passed', {
          senderRemaining: senderLimit.remaining,
          recipientRemaining: recipientLimit.remaining,
        });
      }

      // 5. Process email content for SMS
      const smsContent = processEmailContent(email);
      validator.validateContent(smsContent);

      logger.debug('Content processed for SMS', {
        originalLength: email.text.length,
        smsLength: smsContent.length,
      });

      // 6. Send SMS via Twilio
      const twilioService = createTwilioService(env, logger);
      const smsResult = await twilioService.sendSMS({
        to: phoneResult.phoneNumber,
        from: env.TWILIO_PHONE_NUMBER,
        body: smsContent,
        metadata: {
          emailFrom: email.from,
          emailSubject: email.subject,
          timestamp: new Date().toISOString(),
        },
      });

      // 7. Log successful transaction
      const logEntry: LogEntry = {
        timestamp: new Date().toISOString(),
        emailFrom: email.from,
        emailTo: email.to,
        smsTo: phoneResult.phoneNumber,
        smsFrom: env.TWILIO_PHONE_NUMBER,
        messageLength: smsContent.length,
        status: 'success',
        twilioSid: smsResult.sid,
        processingTimeMs: Date.now() - startTime,
      };

      await logger.logTransaction(logEntry);

      logger.info('Email-to-SMS conversion successful', {
        sid: smsResult.sid,
        processingTime: logEntry.processingTimeMs + 'ms',
      });

    } catch (error) {
      // Handle errors gracefully
      await handleError(error, message, env, logger, startTime);
    }
  },
};

/**
 * Parse email using PostalMime
 */
async function parseEmail(message: ForwardableEmailMessage): Promise<ParsedEmail> {
  const parser = new PostalMime();
  const rawEmail = new Response(message.raw);
  const arrayBuffer = await rawEmail.arrayBuffer();
  const parsed = await parser.parse(arrayBuffer);

  // Extract headers
  const headers: Record<string, string> = {};
  if (parsed.headers) {
    for (const [key, value] of Object.entries(parsed.headers)) {
      if (typeof value === 'string') {
        headers[key.toLowerCase()] = value;
      } else if (Array.isArray(value)) {
        headers[key.toLowerCase()] = value[0]?.toString() || '';
      }
    }
  }

  return {
    from: message.from,
    to: message.to,
    subject: parsed.subject || '',
    text: parsed.text || '',
    html: parsed.html || undefined,
    headers,
    attachments: parsed.attachments?.map(att => ({
      filename: att.filename || 'attachment',
      mimeType: att.mimeType || 'application/octet-stream',
      size: att.content?.length || 0,
    })),
  };
}

/**
 * Centralized error handler
 */
async function handleError(
  error: unknown,
  message: ForwardableEmailMessage,
  env: Env,
  logger: Logger,
  startTime: number
): Promise<void> {
  let errorMessage = 'Internal error processing email';
  let errorCode = 'INTERNAL_ERROR';
  let shouldReject = true;

  if (error instanceof ValidationError) {
    errorMessage = error.message;
    errorCode = error.code;
    shouldReject = true;
  } else if (error instanceof TwilioError) {
    errorMessage = error.message;
    errorCode = `TWILIO_ERROR_${error.code || 'UNKNOWN'}`;
    shouldReject = false; // Don't reject email, log for manual review
  } else if (error instanceof Error) {
    errorMessage = error.message;
    logger.error('Unexpected error', error);
  }

  // Log failed transaction
  const logEntry: LogEntry = {
    timestamp: new Date().toISOString(),
    emailFrom: message.from,
    emailTo: message.to,
    smsTo: 'unknown',
    smsFrom: env.TWILIO_PHONE_NUMBER,
    messageLength: 0,
    status: 'failed',
    error: `${errorCode}: ${errorMessage}`,
    processingTimeMs: Date.now() - startTime,
  };

  await logger.logTransaction(logEntry);

  // Reject email if appropriate
  if (shouldReject) {
    message.setReject(errorMessage);
    logger.warn('Email rejected', {
      reason: errorMessage,
      code: errorCode,
    });
  } else {
    // Don't reject, but log for admin review
    logger.error('Email processing failed but not rejected', error, {
      from: message.from,
      errorCode,
    });

    // Optionally forward to admin for manual review
    // if (env.ADMIN_EMAIL) {
    //   await message.forward(env.ADMIN_EMAIL);
    // }
  }
}
