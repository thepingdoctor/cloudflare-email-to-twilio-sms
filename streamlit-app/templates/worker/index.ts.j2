/**
 * Email-to-SMS Worker
 * Generated by: {{ metadata.generated_by }}
 * Generated at: {{ metadata.generated_at }}
 * Worker: {{ basic.worker_name }}
 */

import { Hono } from 'hono';
import twilio from 'twilio';

// Environment interface
interface Env {
  TWILIO_ACCOUNT_SID: string;
  TWILIO_AUTH_TOKEN: string;
  TWILIO_PHONE_NUMBER: string;
{% if rate_limit.enabled and rate_limit.storage == 'kv' %}
  RATE_LIMIT_KV: KVNamespace;
{% endif %}
{% if logging.storage_type == 'kv' %}
  LOGS_KV: KVNamespace;
{% endif %}
{% if logging.storage_type == 'analytics_engine' %}
  ANALYTICS: AnalyticsEngineDataset;
{% endif %}
}

const app = new Hono<{ Bindings: Env }>();

/**
 * Extract phone number from email
 */
function extractPhoneNumber(
  email: string,
  subject: string,
  headers: Record<string, string>
): string | null {
{% if routing.phone_extraction_method == 'email_prefix' or routing.phone_extraction_method == 'all_methods' %}
  // Try email prefix: 15551234567@sms.example.com
  const emailMatch = email.match(/^(\+?\d+)@/);
  if (emailMatch) {
    let phone = emailMatch[1];
    if (!phone.startsWith('+')) {
      phone = '{{ routing.default_country_code }}' + phone;
    }
    return phone;
  }
{% endif %}

{% if routing.phone_extraction_method == 'subject_line' or routing.phone_extraction_method == 'all_methods' %}
  // Try subject line: "To: +15551234567"
  const subjectPatterns = [
    /to:\s*(\+?\d[\d\s-]+)/i,
    /phone:\s*(\+?\d[\d\s-]+)/i,
    /number:\s*(\+?\d[\d\s-]+)/i,
    /(\+?\d{10,15})/
  ];

  for (const pattern of subjectPatterns) {
    const match = subject.match(pattern);
    if (match) {
      return match[1].replace(/[^\d+]/g, '');
    }
  }
{% endif %}

{% if routing.phone_extraction_method == 'custom_header' or routing.phone_extraction_method == 'all_methods' %}
  // Try custom header: X-SMS-To
  if (headers['x-sms-to']) {
    return headers['x-sms-to'];
  }
{% endif %}

  return null;
}

/**
 * Extract message content from email
 */
function extractContent(textBody: string, htmlBody: string, subject: string): string {
{% if routing.content_source == 'body_text' %}
  let content = textBody || '';
{% elif routing.content_source == 'body_html' %}
  let content = htmlBody || textBody || '';
  {% if routing.strip_html %}
  // Strip HTML tags
  content = content.replace(/<[^>]+>/g, '');
  {% endif %}
{% elif routing.content_source == 'subject' %}
  let content = subject || '';
{% elif routing.content_source == 'subject_and_body' %}
  let content = subject + '\n\n' + (textBody || htmlBody || '');
  {% if routing.strip_html %}
  content = content.replace(/<[^>]+>/g, '');
  {% endif %}
{% endif %}

  // Clean up whitespace
  content = content.replace(/\s+/g, ' ').trim();

  // Truncate to max length
  if (content.length > {{ routing.max_message_length }}) {
    content = content.substring(0, {{ routing.max_message_length - 3 }}) + '...';
  }

{% if routing.include_sender_info %}
  // Add sender info
  content = `[From: ${email}]\n${content}`;
{% endif %}

  return content;
}

{% if rate_limit.enabled %}
/**
 * Check rate limits
 */
async function checkRateLimit(
  env: Env,
  sender: string,
  recipient: string
): Promise<boolean> {
{% if rate_limit.storage == 'kv' %}
  const now = Date.now();
  const hour = Math.floor(now / 3600000);

  // Check sender rate limit
  const senderKey = `rate:sender:${sender}:${hour}`;
  const senderCount = parseInt(await env.RATE_LIMIT_KV.get(senderKey) || '0');
  if (senderCount >= {{ rate_limit.per_sender }}) {
    return false;
  }

  // Check recipient rate limit
  const recipientKey = `rate:recipient:${recipient}:${hour}`;
  const recipientCount = parseInt(await env.RATE_LIMIT_KV.get(recipientKey) || '0');
  if (recipientCount >= {{ rate_limit.per_recipient }}) {
    return false;
  }

  // Increment counters
  await env.RATE_LIMIT_KV.put(senderKey, (senderCount + 1).toString(), {
    expirationTtl: 3600
  });
  await env.RATE_LIMIT_KV.put(recipientKey, (recipientCount + 1).toString(), {
    expirationTtl: 3600
  });
{% else %}
  // In-memory rate limiting (simple implementation)
  // Note: This will reset on worker restart
  return true;
{% endif %}

  return true;
}
{% endif %}

{% if security.enable_sender_whitelist %}
/**
 * Check if sender is whitelisted
 */
function isWhitelisted(email: string): boolean {
  const whitelist = [
{% for sender_email in security.sender_whitelist %}
    '{{ sender_email }}',
{% endfor %}
  ];
  return whitelist.includes(email);
}
{% endif %}

{% if logging.enabled %}
/**
 * Log event
 */
async function logEvent(
  env: Env,
  level: string,
  message: string,
  data?: Record<string, any>
) {
{% if logging.storage_type == 'analytics_engine' %}
  env.ANALYTICS.writeDataPoint({
    blobs: [level, message],
    doubles: [Date.now()],
    indexes: [level]
  });
{% elif logging.storage_type == 'kv' %}
  const logKey = `log:${Date.now()}`;
  await env.LOGS_KV.put(logKey, JSON.stringify({
    level,
    message,
    data,
    timestamp: new Date().toISOString()
  }), { expirationTtl: 86400 * 7 }); // 7 days
{% else %}
  console.log(`[${level.toUpperCase()}] ${message}`, data);
{% endif %}
}
{% endif %}

/**
 * Send SMS via Twilio
 */
async function sendSMS(
  env: Env,
  to: string,
  body: string,
  retryCount = 0
): Promise<boolean> {
  try {
    const client = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);

    await client.messages.create({
      to,
      from: env.TWILIO_PHONE_NUMBER,
      body
    });

{% if logging.enabled %}
    await logEvent(env, 'info', 'SMS sent successfully', { to{% if not logging.log_sensitive_data %}: to.substring(0, 6) + '...'{% endif %} });
{% endif %}

    return true;
  } catch (error) {
{% if retry.enabled %}
    if (retryCount < {{ retry.max_retries }}) {
{% if logging.enabled %}
      await logEvent(env, 'warn', `SMS failed, retrying (${retryCount + 1}/{{ retry.max_retries }})`, { error: error.message });
{% endif %}

{% if retry.backoff_strategy == 'exponential' %}
      const delay = {{ retry.retry_delay }} * Math.pow(2, retryCount) * 1000;
{% elif retry.backoff_strategy == 'linear' %}
      const delay = {{ retry.retry_delay }} * (retryCount + 1) * 1000;
{% else %}
      const delay = {{ retry.retry_delay }} * 1000;
{% endif %}

      await new Promise(resolve => setTimeout(resolve, delay));
      return sendSMS(env, to, body, retryCount + 1);
    }
{% endif %}

{% if logging.enabled %}
    await logEvent(env, 'error', 'SMS send failed', { error: error.message });
{% endif %}

    return false;
  }
}

/**
 * Email handler
 */
app.post('/email', async (c) => {
  try {
    const formData = await c.req.formData();
    const from = formData.get('from') as string;
    const subject = formData.get('subject') as string || '';
    const textBody = formData.get('text') as string || '';
    const htmlBody = formData.get('html') as string || '';
    const to = formData.get('to') as string;

    // Build headers object
    const headers: Record<string, string> = {};
    for (const [key, value] of formData.entries()) {
      if (key.startsWith('x-')) {
        headers[key] = value as string;
      }
    }

{% if security.enable_sender_whitelist %}
    // Check sender whitelist
    if (!isWhitelisted(from)) {
{% if logging.enabled %}
      await logEvent(c.env, 'warn', 'Sender not whitelisted', { from });
{% endif %}
      return c.json({ error: 'Sender not authorized' }, 403);
    }
{% endif %}

    // Extract phone number
    const phone = extractPhoneNumber(to, subject, headers);
    if (!phone) {
{% if logging.enabled %}
      await logEvent(c.env, 'error', 'Could not extract phone number', { to, subject });
{% endif %}
      return c.json({ error: 'Could not determine recipient phone number' }, 400);
    }

{% if rate_limit.enabled %}
    // Check rate limits
    const rateLimitOk = await checkRateLimit(c.env, from, phone);
    if (!rateLimitOk) {
{% if logging.enabled %}
      await logEvent(c.env, 'warn', 'Rate limit exceeded', { from, to: phone });
{% endif %}
      return c.json({ error: 'Rate limit exceeded' }, 429);
    }
{% endif %}

    // Extract message content
    const content = extractContent(textBody, htmlBody, subject);
    if (!content) {
{% if logging.enabled %}
      await logEvent(c.env, 'error', 'Empty message content', { from });
{% endif %}
      return c.json({ error: 'Empty message content' }, 400);
    }

    // Send SMS
    const sent = await sendSMS(c.env, phone, content);

    if (sent) {
      return c.json({
        success: true,
        message: 'SMS sent successfully',
        phone,
        length: content.length
      });
    } else {
      return c.json({ error: 'Failed to send SMS' }, 500);
    }

  } catch (error) {
{% if logging.enabled %}
    await logEvent(c.env, 'error', 'Email processing error', { error: error.message });
{% endif %}
    return c.json({ error: 'Internal server error' }, 500);
  }
});

/**
 * Health check endpoint
 */
app.get('/health', (c) => {
  return c.json({
    status: 'healthy',
    worker: '{{ basic.worker_name }}',
    timestamp: new Date().toISOString()
  });
});

/**
 * Default export
 */
export default app;
