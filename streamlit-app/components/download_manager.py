"""Download and file management components."""
import streamlit as st
import zipfile
import io
from typing import Dict, Optional
from datetime import datetime
import json


def create_zip_archive(files: Dict[str, str], worker_name: str) -> bytes:
    """
    Create ZIP archive with all generated files.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name for ZIP filename

    Returns:
        ZIP file as bytes
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # Add all files to ZIP
        for filepath, content in files.items():
            # Create proper path structure
            zip_path = f"{worker_name}/{filepath}"
            zip_file.writestr(zip_path, content)

    return zip_buffer.getvalue()


def create_deployment_package(files: Dict[str, str], worker_name: str) -> bytes:
    """
    Create deployment package with all files and setup instructions.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name for package

    Returns:
        ZIP file as bytes with deployment-ready structure
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # Add all worker files
        for filepath, content in files.items():
            zip_path = f"{worker_name}/{filepath}"
            zip_file.writestr(zip_path, content)

        # Add quick start guide
        quick_start = f"""# Quick Start Guide - {worker_name}

## 1. Extract & Setup
```bash
unzip {worker_name}-deploy.zip
cd {worker_name}
npm install
```

## 2. Configure Cloudflare Secrets
```bash
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

## 3. Deploy
```bash
npm run deploy
```

## 4. Configure Email Routing
See README.md for detailed email routing setup instructions.

## Support
Generated by email-to-sms-streamlit-generator
"""
        zip_file.writestr(f"{worker_name}/QUICK_START.md", quick_start)

    return zip_buffer.getvalue()


def render_download_section(files: Dict[str, str], worker_name: str, worker_type: str = "standard"):
    """
    Render download section with various download options.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name
        worker_type: Type of worker ("standard" or "email")
    """
    if not files:
        return

    st.markdown("---")
    st.subheader("‚¨áÔ∏è Download & Deploy")

    col1, col2, col3 = st.columns(3)

    with col1:
        # Download as ZIP
        zip_data = create_zip_archive(files, worker_name)
        download_label = "üì¶ Download All Files (.zip)"
        if worker_type == "email":
            download_label = "üìß Download Email Worker (.zip)"

        st.download_button(
            label=download_label,
            data=zip_data,
            file_name=f"{worker_name}.zip",
            mime="application/zip",
            help="Download all files as a ZIP archive",
            use_container_width=True
        )

    with col2:
        # Download deployment package
        if worker_type == "email":
            deployment_package = create_deployment_package(files, worker_name)
            st.download_button(
                label="üöÄ Deployment Package",
                data=deployment_package,
                file_name=f"{worker_name}-deploy.zip",
                mime="application/zip",
                help="Download ready-to-deploy package with dependencies",
                use_container_width=True
            )
        else:
            st.button(
                "üìÑ Download Individual Files",
                help="Downloads are available in each code tab above",
                disabled=True,
                use_container_width=True
            )

    with col3:
        # Export configuration
        config_json = export_configuration(files)
        st.download_button(
            label="‚öôÔ∏è Export Configuration",
            data=config_json,
            file_name=f"{worker_name}-config.json",
            mime="application/json",
            help="Save configuration for later reuse",
            use_container_width=True
        )


def export_configuration(files: Dict[str, str]) -> str:
    """
    Export configuration as JSON.

    Args:
        files: Dictionary mapping filenames to content

    Returns:
        JSON string of configuration
    """
    import json

    # Extract config from session state
    config = {
        "worker_name": st.session_state.get('worker_name', ''),
        "domain": st.session_state.get('domain', ''),
        "email_pattern": st.session_state.get('email_pattern', ''),
        "generated_at": datetime.utcnow().isoformat() + 'Z'
    }

    return json.dumps(config, indent=2)


def render_deployment_instructions(worker_name: str, domain: str, email_pattern: str, worker_type: str = "standard"):
    """
    Render deployment instructions based on worker type.

    Args:
        worker_name: Worker name
        domain: Domain name
        email_pattern: Email pattern
        worker_type: Type of worker ("standard" or "email")
    """
    st.markdown("---")
    st.subheader("üöÄ Deployment Instructions")

    if worker_type == "email":
        with st.expander("üìñ Email Worker Quick Start Guide", expanded=True):
            st.markdown(f"""
### 1. Extract Files

```bash
unzip {worker_name}.zip
cd {worker_name}
```

### 2. Install Dependencies

```bash
npm install
```

### 3. Configure Cloudflare Secrets

```bash
# Twilio credentials
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

### 4. Deploy Email Worker

```bash
npm run deploy
```

### 5. Configure Cloudflare Email Routing

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com/)
2. Navigate to your domain ‚Üí **Email** ‚Üí **Email Routing**
3. Click **Enable Email Routing** if not already enabled
4. Add a **Custom Address** routing rule:
   - **Match:** `{email_pattern.replace('{domain}', domain)}`
   - **Action:** Send to Worker
   - **Destination Worker:** `{worker_name}`

### 6. Verify Email Routing

```bash
# Check worker is deployed
wrangler whoami
wrangler deployments list --name {worker_name}
```

### 7. Test Email-to-SMS

Send a test email to: `15551234567@{domain}` (where 15551234567 is the recipient's phone number)

**Email Format:**
- **To:** `<phone-number>@{domain}`
- **Subject:** (optional, can be included in SMS)
- **Body:** Message content (will be truncated to SMS limits)

### 8. Monitor & Debug

```bash
# View real-time logs
wrangler tail {worker_name}

# Check email routing status
# Dashboard ‚Üí Email ‚Üí Email Routing ‚Üí Logs
```

### Troubleshooting

- **Email not being processed?**
  - Verify email routing is enabled on your domain
  - Check routing rule matches your email pattern
  - Confirm worker is set as destination

- **SMS not sending?**
  - Check `wrangler tail` for errors
  - Verify Twilio credentials with `wrangler secret list`
  - Ensure phone number format is correct (E.164 format)

- **Rate limiting errors?**
  - Check KV namespace is created and bound
  - Verify rate limit settings in wrangler.toml

- **Invalid recipient?**
  - Email address must contain valid phone number
  - Default format: `<10-digit-number>@{domain}`
        """)
    else:
        with st.expander("üìñ Quick Start Guide", expanded=True):
            st.markdown(f"""
### 1. Extract Files

```bash
unzip {worker_name}.zip
cd {worker_name}
```

### 2. Install Dependencies

```bash
npm install
```

### 3. Configure Secrets

```bash
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

### 4. Deploy to Cloudflare

```bash
npm run deploy
```

### 5. Configure Email Routing

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com/)
2. Navigate to **Email** ‚Üí **Email Routing**
3. Add domain: `{domain}`
4. Create routing rule:
   - **Match:** `{email_pattern.replace('{domain}', domain)}`
   - **Action:** Send to Worker
   - **Worker:** `{worker_name}`

### 6. Test

Send a test email to: `{email_pattern.replace('{domain}', domain).replace('*', '15551234567')}`

### Troubleshooting

- **Not receiving SMS?** Check `wrangler tail` for logs
- **Email not routing?** Verify Email Routing configuration
- **Errors?** Check Twilio credentials are set correctly
        """)

    with st.expander("üîß Advanced Configuration"):
        st.markdown("""
### Local Development

```bash
npm run dev
```

### Type Checking

```bash
npm run check
```

### Testing

```bash
npm test
```

### View Logs

```bash
wrangler tail
```

### Update Secrets

```bash
wrangler secret put SECRET_NAME
```

### Create KV Namespace (if using rate limiting)

```bash
wrangler kv:namespace create "RATE_LIMIT_KV"
# Update wrangler.toml with the namespace ID
```
        """)


def render_copy_buttons(files: Dict[str, str]):
    """
    Render copy-to-clipboard functionality.

    Args:
        files: Dictionary mapping filenames to content
    """
    st.markdown("### üìã Quick Copy")

    # Create columns for quick copy buttons
    cols = st.columns(min(len(files), 4))

    for i, (filename, content) in enumerate(files.items()):
        with cols[i % 4]:
            st.button(
                f"Copy {filename}",
                key=f"copy_{filename}",
                help=f"Copy {filename} to clipboard",
                use_container_width=True
            )


def render_import_section():
    """
    Render configuration import section (available at app start).
    This allows users to import a previously saved configuration.
    """
    st.markdown("### üì§ Import Configuration")
    
    st.info("üí° Load a previously saved configuration to quickly populate all settings.")
    
    uploaded_file = st.file_uploader(
        "Upload Configuration JSON",
        type=['json'],
        help="Load a previously exported configuration file",
        key="config_import_uploader"
    )

    if uploaded_file:
        try:
            loaded_config = json.load(uploaded_file)
            
            # Validate config structure
            if not isinstance(loaded_config, dict):
                st.error("‚ùå Invalid configuration file format")
                return
            
            st.success(f"‚úÖ Configuration file loaded: **{uploaded_file.name}**")
            
            # Show preview of what will be imported
            with st.expander("üìã Preview Configuration"):
                st.json(loaded_config)
            
            col1, col2 = st.columns([1, 3])
            
            with col1:
                if st.button("üöÄ Apply Configuration", type="primary", use_container_width=True):
                    apply_imported_config(loaded_config)
                    st.success("‚úÖ Configuration applied successfully!")
                    st.balloons()
                    st.rerun()
            
            with col2:
                st.caption("This will populate all form fields with the imported values")
                
        except json.JSONDecodeError as e:
            st.error(f"‚ùå Invalid JSON file: {str(e)}")
        except Exception as e:
            st.error(f"‚ùå Error loading configuration: {str(e)}")
            st.exception(e)


def apply_imported_config(config_dict: dict):
    """
    Apply imported configuration to session state.
    Maps nested config structure to flat session state keys used by form components.
    
    Args:
        config_dict: Dictionary representation of WorkerConfig
    """
    # Map basic settings
    if 'basic' in config_dict:
        basic = config_dict['basic']
        st.session_state['worker_name'] = basic.get('worker_name', 'email-to-sms-worker')
        st.session_state['domain'] = basic.get('domain', '')
        st.session_state['email_pattern'] = basic.get('email_pattern', '*@sms.{domain}')
    
    # Map Twilio settings
    if 'twilio' in config_dict:
        twilio = config_dict['twilio']
        st.session_state['twilio_sid'] = twilio.get('account_sid', '')
        st.session_state['twilio_token'] = twilio.get('auth_token', '')
        st.session_state['twilio_phone'] = twilio.get('phone_number', '')
    
    # Map routing settings
    if 'routing' in config_dict:
        routing = config_dict['routing']
        st.session_state['phone_extraction'] = routing.get('phone_extraction_method', 'email_prefix')
        st.session_state['country_code'] = routing.get('default_country_code', '+1')
        st.session_state['content_source'] = routing.get('content_source', 'body_text')
        st.session_state['max_length'] = routing.get('max_message_length', 160)
        st.session_state['strip_html'] = routing.get('strip_html', True)
        st.session_state['include_sender'] = routing.get('include_sender_info', False)
    
    # Map rate limit settings
    if 'rate_limit' in config_dict:
        rate_limit = config_dict['rate_limit']
        st.session_state['rate_limit_enabled'] = rate_limit.get('enabled', True)
        st.session_state['rate_sender'] = rate_limit.get('per_sender', 10)
        st.session_state['rate_recipient'] = rate_limit.get('per_recipient', 20)
        st.session_state['rate_storage'] = rate_limit.get('storage', 'kv')
    
    # Map logging settings
    if 'logging' in config_dict:
        logging = config_dict['logging']
        st.session_state['logging_enabled'] = logging.get('enabled', True)
        st.session_state['log_storage'] = logging.get('storage_type', 'analytics_engine')
        st.session_state['log_level'] = logging.get('log_level', 'info')
        st.session_state['log_sensitive'] = logging.get('log_sensitive_data', False)
    
    # Map security settings
    if 'security' in config_dict:
        security = config_dict['security']
        st.session_state['whitelist_enabled'] = security.get('enable_sender_whitelist', False)
        # Convert list to newline-separated string for text area
        whitelist = security.get('sender_whitelist', [])
        st.session_state['whitelist'] = '\n'.join(whitelist) if whitelist else ''
        st.session_state['content_filter'] = security.get('enable_content_filtering', False)
    
    # Map retry settings
    if 'retry' in config_dict:
        retry = config_dict['retry']
        st.session_state['retries_enabled'] = retry.get('enabled', True)
        st.session_state['max_retries'] = retry.get('max_retries', 3)
        st.session_state['retry_delay'] = retry.get('retry_delay', 5)
        st.session_state['backoff'] = retry.get('backoff_strategy', 'exponential')
    
    # Map integration settings
    if 'integrations' in config_dict:
        integrations = config_dict['integrations']
        st.session_state['url_shorten'] = integrations.get('enable_url_shortening', False)
        st.session_state['error_notify'] = integrations.get('enable_error_notifications', False)
        st.session_state['notify_email'] = integrations.get('notification_email', '')


def render_export_options(config):
    """
    Render configuration export options.

    Args:
        config: WorkerConfig object
    """
    st.markdown("### üíæ Save Configuration")

    col1, col2 = st.columns(2)

    with col1:
        # Export as JSON
        config_json = config.to_dict()
        json_str = json.dumps(config_json, indent=2)

        st.download_button(
            label="üì• Export Configuration as JSON",
            data=json_str,
            file_name=f"{config.basic.worker_name}-config.json",
            mime="application/json",
            help="Save configuration for later reuse - can be imported on next use",
            use_container_width=True
        )

    with col2:
        st.info("üí° **Tip:** Export your configuration to reuse it later with the Import feature at the top of the page.")


def show_download_success():
    """Show success message after download."""
    st.success("‚úÖ Files downloaded successfully!")
    st.balloons()
