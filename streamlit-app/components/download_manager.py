"""Download and file management components."""
import streamlit as st
import zipfile
import io
from typing import Dict
from datetime import datetime


def create_zip_archive(files: Dict[str, str], worker_name: str) -> bytes:
    """
    Create ZIP archive with all generated files.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name for ZIP filename

    Returns:
        ZIP file as bytes
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # Add all files to ZIP
        for filepath, content in files.items():
            # Create proper path structure
            zip_path = f"{worker_name}/{filepath}"
            zip_file.writestr(zip_path, content)

    return zip_buffer.getvalue()


def create_deployment_package(files: Dict[str, str], worker_name: str) -> bytes:
    """
    Create deployment package with all files and setup instructions.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name for package

    Returns:
        ZIP file as bytes with deployment-ready structure
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        # Add all worker files
        for filepath, content in files.items():
            zip_path = f"{worker_name}/{filepath}"
            zip_file.writestr(zip_path, content)

        # Add quick start guide
        quick_start = f"""# Quick Start Guide - {worker_name}

## 1. Extract & Setup
```bash
unzip {worker_name}-deploy.zip
cd {worker_name}
npm install
```

## 2. Configure Cloudflare Secrets
```bash
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

## 3. Deploy
```bash
npm run deploy
```

## 4. Configure Email Routing
See README.md for detailed email routing setup instructions.

## Support
Generated by email-to-sms-streamlit-generator
"""
        zip_file.writestr(f"{worker_name}/QUICK_START.md", quick_start)

    return zip_buffer.getvalue()


def render_download_section(files: Dict[str, str], worker_name: str, worker_type: str = "standard"):
    """
    Render download section with various download options.

    Args:
        files: Dictionary mapping filenames to content
        worker_name: Worker name
        worker_type: Type of worker ("standard" or "email")
    """
    if not files:
        return

    st.markdown("---")
    st.subheader("‚¨áÔ∏è Download & Deploy")

    col1, col2, col3 = st.columns(3)

    with col1:
        # Download as ZIP
        zip_data = create_zip_archive(files, worker_name)
        download_label = "üì¶ Download All Files (.zip)"
        if worker_type == "email":
            download_label = "üìß Download Email Worker (.zip)"

        st.download_button(
            label=download_label,
            data=zip_data,
            file_name=f"{worker_name}.zip",
            mime="application/zip",
            help="Download all files as a ZIP archive",
            use_container_width=True
        )

    with col2:
        # Download deployment package
        if worker_type == "email":
            deployment_package = create_deployment_package(files, worker_name)
            st.download_button(
                label="üöÄ Deployment Package",
                data=deployment_package,
                file_name=f"{worker_name}-deploy.zip",
                mime="application/zip",
                help="Download ready-to-deploy package with dependencies",
                use_container_width=True
            )
        else:
            st.button(
                "üìÑ Download Individual Files",
                help="Downloads are available in each code tab above",
                disabled=True,
                use_container_width=True
            )

    with col3:
        # Export configuration
        config_json = export_configuration(files)
        st.download_button(
            label="‚öôÔ∏è Export Configuration",
            data=config_json,
            file_name=f"{worker_name}-config.json",
            mime="application/json",
            help="Save configuration for later reuse",
            use_container_width=True
        )


def export_configuration(files: Dict[str, str]) -> str:
    """
    Export configuration as JSON.

    Args:
        files: Dictionary mapping filenames to content

    Returns:
        JSON string of configuration
    """
    import json

    # Extract config from session state
    config = {
        "worker_name": st.session_state.get('worker_name', ''),
        "domain": st.session_state.get('domain', ''),
        "email_pattern": st.session_state.get('email_pattern', ''),
        "generated_at": datetime.utcnow().isoformat() + 'Z'
    }

    return json.dumps(config, indent=2)


def render_deployment_instructions(worker_name: str, domain: str, email_pattern: str, worker_type: str = "standard"):
    """
    Render deployment instructions based on worker type.

    Args:
        worker_name: Worker name
        domain: Domain name
        email_pattern: Email pattern
        worker_type: Type of worker ("standard" or "email")
    """
    st.markdown("---")
    st.subheader("üöÄ Deployment Instructions")

    if worker_type == "email":
        with st.expander("üìñ Email Worker Quick Start Guide", expanded=True):
            st.markdown(f"""
### 1. Extract Files

```bash
unzip {worker_name}.zip
cd {worker_name}
```

### 2. Install Dependencies

```bash
npm install
```

### 3. Configure Cloudflare Secrets

```bash
# Twilio credentials
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

### 4. Deploy Email Worker

```bash
npm run deploy
```

### 5. Configure Cloudflare Email Routing

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com/)
2. Navigate to your domain ‚Üí **Email** ‚Üí **Email Routing**
3. Click **Enable Email Routing** if not already enabled
4. Add a **Custom Address** routing rule:
   - **Match:** `{email_pattern.replace('{domain}', domain)}`
   - **Action:** Send to Worker
   - **Destination Worker:** `{worker_name}`

### 6. Verify Email Routing

```bash
# Check worker is deployed
wrangler whoami
wrangler deployments list --name {worker_name}
```

### 7. Test Email-to-SMS

Send a test email to: `15551234567@{domain}` (where 15551234567 is the recipient's phone number)

**Email Format:**
- **To:** `<phone-number>@{domain}`
- **Subject:** (optional, can be included in SMS)
- **Body:** Message content (will be truncated to SMS limits)

### 8. Monitor & Debug

```bash
# View real-time logs
wrangler tail {worker_name}

# Check email routing status
# Dashboard ‚Üí Email ‚Üí Email Routing ‚Üí Logs
```

### Troubleshooting

- **Email not being processed?**
  - Verify email routing is enabled on your domain
  - Check routing rule matches your email pattern
  - Confirm worker is set as destination

- **SMS not sending?**
  - Check `wrangler tail` for errors
  - Verify Twilio credentials with `wrangler secret list`
  - Ensure phone number format is correct (E.164 format)

- **Rate limiting errors?**
  - Check KV namespace is created and bound
  - Verify rate limit settings in wrangler.toml

- **Invalid recipient?**
  - Email address must contain valid phone number
  - Default format: `<10-digit-number>@{domain}`
        """)
    else:
        with st.expander("üìñ Quick Start Guide", expanded=True):
            st.markdown(f"""
### 1. Extract Files

```bash
unzip {worker_name}.zip
cd {worker_name}
```

### 2. Install Dependencies

```bash
npm install
```

### 3. Configure Secrets

```bash
wrangler secret put TWILIO_ACCOUNT_SID
wrangler secret put TWILIO_AUTH_TOKEN
wrangler secret put TWILIO_PHONE_NUMBER
```

### 4. Deploy to Cloudflare

```bash
npm run deploy
```

### 5. Configure Email Routing

1. Go to [Cloudflare Dashboard](https://dash.cloudflare.com/)
2. Navigate to **Email** ‚Üí **Email Routing**
3. Add domain: `{domain}`
4. Create routing rule:
   - **Match:** `{email_pattern.replace('{domain}', domain)}`
   - **Action:** Send to Worker
   - **Worker:** `{worker_name}`

### 6. Test

Send a test email to: `{email_pattern.replace('{domain}', domain).replace('*', '15551234567')}`

### Troubleshooting

- **Not receiving SMS?** Check `wrangler tail` for logs
- **Email not routing?** Verify Email Routing configuration
- **Errors?** Check Twilio credentials are set correctly
        """)

    with st.expander("üîß Advanced Configuration"):
        st.markdown("""
### Local Development

```bash
npm run dev
```

### Type Checking

```bash
npm run check
```

### Testing

```bash
npm test
```

### View Logs

```bash
wrangler tail
```

### Update Secrets

```bash
wrangler secret put SECRET_NAME
```

### Create KV Namespace (if using rate limiting)

```bash
wrangler kv:namespace create "RATE_LIMIT_KV"
# Update wrangler.toml with the namespace ID
```
        """)


def render_copy_buttons(files: Dict[str, str]):
    """
    Render copy-to-clipboard functionality.

    Args:
        files: Dictionary mapping filenames to content
    """
    st.markdown("### üìã Quick Copy")

    # Create columns for quick copy buttons
    cols = st.columns(min(len(files), 4))

    for i, (filename, content) in enumerate(files.items()):
        with cols[i % 4]:
            st.button(
                f"Copy {filename}",
                key=f"copy_{filename}",
                help=f"Copy {filename} to clipboard",
                use_container_width=True
            )


def render_export_options(config):
    """
    Render configuration export options.

    Args:
        config: WorkerConfig object
    """
    st.markdown("### üíæ Save Configuration")

    col1, col2 = st.columns(2)

    with col1:
        # Export as JSON
        config_json = config.to_dict()
        import json
        json_str = json.dumps(config_json, indent=2)

        st.download_button(
            label="üì• Export as JSON",
            data=json_str,
            file_name=f"{config.basic.worker_name}-config.json",
            mime="application/json",
            help="Save configuration for later reuse",
            use_container_width=True
        )

    with col2:
        # Load from JSON
        uploaded_file = st.file_uploader(
            "üì§ Import Configuration",
            type=['json'],
            help="Load previously saved configuration",
            key="config_upload"
        )

        if uploaded_file:
            try:
                import json
                loaded_config = json.load(uploaded_file)
                st.success("‚úÖ Configuration loaded! Click 'Apply' to use it.")

                if st.button("Apply Configuration"):
                    # Update session state with loaded config
                    for key, value in loaded_config.items():
                        if isinstance(value, dict):
                            for sub_key, sub_value in value.items():
                                st.session_state[sub_key] = sub_value
                        else:
                            st.session_state[key] = value
                    st.rerun()
            except Exception as e:
                st.error(f"‚ùå Error loading configuration: {str(e)}")


def show_download_success():
    """Show success message after download."""
    st.success("‚úÖ Files downloaded successfully!")
    st.balloons()
