/**
 * Email-to-SMS Worker
 * Generated by: email-to-sms-streamlit-generator
 * Generated at: 2025-11-14T00:58:49.510010Z
 * Worker: security-test-worker
 */

import { Hono } from 'hono';
import twilio from 'twilio';

// Environment interface
interface Env {
  TWILIO_ACCOUNT_SID: string;
  TWILIO_AUTH_TOKEN: string;
  TWILIO_PHONE_NUMBER: string;
  RATE_LIMIT_KV: KVNamespace;
  ANALYTICS: AnalyticsEngineDataset;
}

const app = new Hono<{ Bindings: Env }>();

/**
 * Extract phone number from email
 */
function extractPhoneNumber(
  email: string,
  subject: string,
  headers: Record<string, string>
): string | null {
  // Try email prefix: 15551234567@sms.example.com
  const emailMatch = email.match(/^(\+?\d+)@/);
  if (emailMatch) {
    let phone = emailMatch[1];
    if (!phone.startsWith('+')) {
      phone = '+1' + phone;
    }
    return phone;
  }



  return null;
}

/**
 * Extract message content from email
 */
function extractContent(textBody: string, htmlBody: string, subject: string): string {
  let content = textBody || '';

  // Clean up whitespace
  content = content.replace(/\s+/g, ' ').trim();

  // Truncate to max length
  if (content.length > 160) {
    content = content.substring(0, 157) + '...';
  }


  return content;
}

/**
 * Check rate limits
 */
async function checkRateLimit(
  env: Env,
  sender: string,
  recipient: string
): Promise<boolean> {
  const now = Date.now();
  const hour = Math.floor(now / 3600000);

  // Check sender rate limit
  const senderKey = `rate:sender:${sender}:${hour}`;
  const senderCount = parseInt(await env.RATE_LIMIT_KV.get(senderKey) || '0');
  if (senderCount >= 10) {
    return false;
  }

  // Check recipient rate limit
  const recipientKey = `rate:recipient:${recipient}:${hour}`;
  const recipientCount = parseInt(await env.RATE_LIMIT_KV.get(recipientKey) || '0');
  if (recipientCount >= 20) {
    return false;
  }

  // Increment counters
  await env.RATE_LIMIT_KV.put(senderKey, (senderCount + 1).toString(), {
    expirationTtl: 3600
  });
  await env.RATE_LIMIT_KV.put(recipientKey, (recipientCount + 1).toString(), {
    expirationTtl: 3600
  });

  return true;
}


/**
 * Log event
 */
async function logEvent(
  env: Env,
  level: string,
  message: string,
  data?: Record<string, any>
) {
  env.ANALYTICS.writeDataPoint({
    blobs: [level, message],
    doubles: [Date.now()],
    indexes: [level]
  });
}

/**
 * Send SMS via Twilio
 */
async function sendSMS(
  env: Env,
  to: string,
  body: string,
  retryCount = 0
): Promise<boolean> {
  try {
    const client = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);

    await client.messages.create({
      to,
      from: env.TWILIO_PHONE_NUMBER,
      body
    });

    await logEvent(env, 'info', 'SMS sent successfully', { to: to.substring(0, 6) + '...' });

    return true;
  } catch (error) {
    if (retryCount < 3) {
      await logEvent(env, 'warn', `SMS failed, retrying (${retryCount + 1}/3)`, { error: error.message });

      const delay = 5 * Math.pow(2, retryCount) * 1000;

      await new Promise(resolve => setTimeout(resolve, delay));
      return sendSMS(env, to, body, retryCount + 1);
    }

    await logEvent(env, 'error', 'SMS send failed', { error: error.message });

    return false;
  }
}

/**
 * Email handler
 */
app.post('/email', async (c) => {
  try {
    const formData = await c.req.formData();
    const from = formData.get('from') as string;
    const subject = formData.get('subject') as string || '';
    const textBody = formData.get('text') as string || '';
    const htmlBody = formData.get('html') as string || '';
    const to = formData.get('to') as string;

    // Build headers object
    const headers: Record<string, string> = {};
    for (const [key, value] of formData.entries()) {
      if (key.startsWith('x-')) {
        headers[key] = value as string;
      }
    }


    // Extract phone number
    const phone = extractPhoneNumber(to, subject, headers);
    if (!phone) {
      await logEvent(c.env, 'error', 'Could not extract phone number', { to, subject });
      return c.json({ error: 'Could not determine recipient phone number' }, 400);
    }

    // Check rate limits
    const rateLimitOk = await checkRateLimit(c.env, from, phone);
    if (!rateLimitOk) {
      await logEvent(c.env, 'warn', 'Rate limit exceeded', { from, to: phone });
      return c.json({ error: 'Rate limit exceeded' }, 429);
    }

    // Extract message content
    const content = extractContent(textBody, htmlBody, subject);
    if (!content) {
      await logEvent(c.env, 'error', 'Empty message content', { from });
      return c.json({ error: 'Empty message content' }, 400);
    }

    // Send SMS
    const sent = await sendSMS(c.env, phone, content);

    if (sent) {
      return c.json({
        success: true,
        message: 'SMS sent successfully',
        phone,
        length: content.length
      });
    } else {
      return c.json({ error: 'Failed to send SMS' }, 500);
    }

  } catch (error) {
    await logEvent(c.env, 'error', 'Email processing error', { error: error.message });
    return c.json({ error: 'Internal server error' }, 500);
  }
});

/**
 * Health check endpoint
 */
app.get('/health', (c) => {
  return c.json({
    status: 'healthy',
    worker: 'security-test-worker',
    timestamp: new Date().toISOString()
  });
});

/**
 * Default export
 */
export default app;